首先，先得清楚 final 这个关键字。 
final的出现就是为了为了不想改变，而不想改变的理由有两点：设计(安全)或者效率。
final 修饰的类是不被能继承的，所以 final 修饰的类是不能被篡改的。 
了解了这一点，我们再看看问题：

1、从设计安全)上讲， 
1)、确保它们不会在子类中改变语义。String类是final类，这意味着不允许任何人定义String的子类。
换言之，
如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。 
2)、String 一旦被创建是不能被修改的，
因为 java 设计者将 String 为可以共享的，下面这段是源码中的注释：







2、从效率上讲： 
1)、设计成final，JVM才不用对相关方法在虚函数表中查询，而直接定位到String类的相关方法上，提高了执行效率。 
2)、Java设计者认为共享带来的效率更高。

总而言之，就是要保证 java.lang.String 引用的对象一定是 java.lang.String的对象，而不是引用它的子孙类，这样才能保证它的效率和安全。



java中class.forName()和classLoader都可用来对类进行加载。
class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象



redis数据结构：String、List、Set、Hash、Zset
redis持久化：aof和rdb
两种持久化方式一起用的，why，当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。



Java虚拟机规范中规定了对内存的分配，其中程序计数器、本地方法栈、虚拟机栈属于线程私有数据区，Java堆与方法区属于线程共享数据。
Jdk从1.7开始将字符串常量区由方法区(永久代)移动到了Java堆中。
Java从NIO开始允许直接操纵系统的直接内存，在部分场景中效率很高，因为避免了在Java堆与Native堆中来回复制数据。
Java堆分为年轻代有年老代，其中年轻代分为1个Eden与2个Survior，同时只有1个Eden与1个Survior处于使用中状态，又有年轻代的对象生存时间为往往很短，因此使用复制算法进行垃圾回收。
年老代由于对象存活期比较长，并且没有可担保的数据区，所以往往使用标记-清除与标记-整理算法进行垃圾回收。




@刘一阳 这个能采集到新增数据，但是修改后好像不能同步


java8 新增了非常多的特性，我们主要讨论以下几个：
Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。
方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。
新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
Date Time API − 加强对日期与时间的处理。
Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。




3.5CocurrentHashMap是由Segment数组和HashEntry数组组成。
Segment是重入锁(ReentrantLock),作为一个数据段竞争锁，每个HashEntry一个链表结构的元素，利用Hash算法得到索引确定归属的数据段，也就是对应到在修改时需要竞争获取的锁。




头插入，链表效率高，查找效率一样，删除链表高；
中间插入，具体要看数据的多少，查找数组快，删除看数据；
尾部插入，查找，删除效率都差不多






2.1  ApplicationContext接口,它由BeanFactory接口派生而来，因而提供BeanFactory所有的功能。ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承，ApplicationContext包还提供了以下的功能： 
  • MessageSource, 提供国际化的消息访问  
  • 资源访问，如URL和文件  
  • 事件传播  
  • 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  



Spring常用的三种注入方式：构造注入，setter注入，注解注入
接口注入

IOC控制反转，通过注入方式让spring管理对象的生命周期
AOP面向切面，让程序主逻辑和次级逻辑分离，各自单独编码

aop采用jdk动态代理（基于接口）或者cglib（基于类）
spring实现事务管理一般使用基于AOP技术的声明式事务管理
实质就是：在方法执行前后进行拦截，然后在目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务。




代理就是类增强处理



3.1  start是开启现成，run方法里面写的是线程执行的逻辑

3.2 newCachedThreadPool：适用：执行很多短期异步的小程序或者负载较轻的服务器

newFixedThreadPool：适用：执行长期的任务，性能好很多
newSingleThreadExecutor:适用：一个任务一个任务执行的场景

NewScheduledThreadPool：适用：周期性执行任务的场景




调用 start是开启新线程执行，调用run方法就是普通执行不会开启新线程



3.3 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。
  
  
  
  
  
3.4 可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。区别是：争用下的 ReentrantLock 实现更具可伸缩性；



3.5CocurrentHashMap是由Segment数组和HashEntry数组组成。
Segment是重入锁(ReentrantLock),作为一个数据段竞争锁，每个HashEntry一个链表结构的元素，利用Hash算法得到索引确定归属的数据段，也就是对应到在修改时需要竞争获取的锁。




4.1 http请求：get，post，head，delete。。。。可以自定义，导入httpclient包



4.2 NIO:同步非阻塞；AIO:异步非阻塞
如果把内核比作快递，NIO就是你要自己时不时到官网查下快递是否已经到了你所在城市，然后自己去取快递；AIO就是快递员送货上门了。


4.3 Netty介绍
按照定义来说，Netty是一个异步、事件驱动的用来做高性能、高可靠性的网络应用框架。主要的优点有：
框架设计优雅，底层模型随意切换适应不同的网络协议要求
提供很多标准的协议、安全、编码解码的支持
解决了很多NIO不易用的问题
社区更为活跃，在很多开源框架中使用，如Dubbo、RocketMQ、Spark等










4.4 同步，就是发起调用后，被调用者处理消息，必须等处理完才直接返回结果，没处理完之前是不返回的，调用者主动等待结果；异步，就是发起调用后，被调用者直接返回，但是并没有返回结果，等处理完消息后，通过状态、通知或者回调函数来通知调用者，调用者被动接收结果；涉及到CPU线程调度；所谓阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行；所谓非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。


8.1 shuffle是不同节点之间的数据拉取过程；调优的点有一些基本的参数，比如buffer的容量，io。retrywait的时间，也可以先将数据预聚合来缩减shuffle时数据的体积



zk用到的场景 分布式锁 动态感知服务器上下线 HDFS的namenode stndy active切换 zkfc    

用的zk的临时节点 用有序列号的临时节点也可以
























