TRUNCATE TABLE：删除内容、释放空间但不删除定义。
DELETE TABLE:删除内容不删除定义，不释放空间。
1、TRUNCATE在各种表上无论是大的还是小的都非常快。如果有ROLLBACK命令DELETE将被撤销，而TRUNCATE则不会被撤销。
2、TRUNCATE是一个DDL语言，向其他所有的DDL语言一样，他将被隐式提交，不能对TRUNCATE使用ROLLBACK命令。 
3、TRUNCATE将重新设置高水平线和所有的索引。在对整个表和索引进行完全浏览时，经过TRUNCATE操作后的表比DELETE操作后的表要快得多。
4、TRUNCATE不能触发任何DELETE触发器。 
5、不能授予任何人清空他人的表的权限。 
6、当表被清空后表和表的索引将重新设置成初始大小，而delete则不能。
7、不能清空父表。 TRUNCATE TABLE (schema)table_name DROP(REUSE) STORAGE 在默认是 DROP STORAGE 当使用DROP STORAGE时将缩短表和表索引，将表收缩到最小范围，并重新设置NEXT参数。
REUSE STORAGE不会缩短表或者调整NEXT参数在特殊情况下使用 REUSE ST DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的的删除操作作为事务记录在日志中保存以便进行进行回滚操作  
TRUNCATE TABLE 则一次性地从表中删除所有的数据页并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。
并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。


JDBC的数据库操作中，一项事务是由一条或是多条表达式所组成的一个不可分割的工作单元。我们通过提交commit()或是回退rollback()来结束事务的操作。关于事务操作的方法都位于接口java.sql.Connection中。首先我们要注意，在JDBC中，事务操作默认是自动提交。也就是说，一条对数据库的更新表达式代表一项事务操作。操作成功后，系统将自动调用commit()来提交，否则将调用rollback()来回退。其次，在JDBC中，可以通过调用setAutoCommit(false)来禁止自动提交。之后就可以把多个数据库操作的表达式作为一个事务，在 操作完成后调用commit()来进行整体提交。倘若其中一个表达式操作失败，都不会执行到commit()，并且将产生响应的异常。此时就可以在异常捕 获时调用rollback()进行回退。这样做可以保持多次更新操作后，相关数据的一致性。

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。



GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
GET书签可收藏，POST为书签不可收藏。
GET能被缓存，POST不能缓存 。
GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。
GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。
GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。
与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。






什么是Java垃圾回收器
Java垃圾回收器是Java虚拟机(JVM)的三个重要模块(另外两个是解释器和多线程机制)之一，为应用程序提供内存的自动分配(Memory Allocation)、自动回收(Garbage Collect)功能，这两个操作都发生在Java堆上(一段内存快)。某一个时点，一个对象如果有一个以上的引用(Rreference)指向它，那么该对象就为活着的(Live)，否则死亡(Dead)，视为垃圾，可被垃圾回收器回收再利用。垃圾回收操作需要消耗CPU、线程、时间等资源，所以容易理解的是垃圾回收操作不是实时的发生(对象死亡马上释放)，当内存消耗完或者是达到某一个指标(Threshold,使用内存占总内存的比列，比如0.75)时，触发垃圾回收操作。有一个对象死亡的例外，java.lang.Thread类型的对象即使没有引用，只要线程还在运行，就不会被回收。


如果JDBC连接是在自动提交模式下，它在默认情况下，那么每个SQL语句都是在其完成时提交到数据库。
这可能是对简单的应用程序，但有三个原因，你可能想关闭自动提交和管理自己的事务：
为了提高性能
为了保持业务流程的完整性
使用分布式事务
若要控制事务，以及何时更改应用到数据库。它把单个SQL语句或一组SQL语句作为一个逻辑单元，而且如果任何语句失败，整个事务失败。
若要启用，而不是JDBC驱动程序默认使用auto-commit模式手动事务支持，使用Connection对象的的setAutoCommit()方法。如果传递一个布尔值false到setAutoCommit()，关闭自动提交。可以传递一个布尔值true将其重新打开。



t1.run();  只是调用了一个普通方法，并没有启动另一个线程，程序还是会按照顺序执行相应的代码。

t1.start();  则表示，重新开启一个线程，不必等待其他线程运行完，只要得到cup就可以运行该线程。




性能指标(Performance Metrics)
生产率(Throughput)
一个较长的周期(长的周期才有意义)内，非回收时间占总时间的比率。度量系统的运行效率。
垃圾回收花费(Garbage Collection overhead)
一个较长的周期内，回收时间占总时间的比率。与生产率相对应，加起来为100%。
暂停时间间隔(Pause time)
Java虚拟机在回收垃圾的时候，有的算法会暂停所有应用线程的执行，某些系统可能对暂停的时间间隔比较敏感。
回收的频率(Frequency of collection)
平均多久会发生回收操作。
内存占用的大小(Footprint)
如堆的大小。
实时性(Promptness)
自一个对象死亡起，经过多久该对象所占用内存被回收。



BlockingQueue接口的实现LinkedBlockingQueue

LinkedBlockingQueue继承了AbstractQueue，实现了BlockingQueue接口；
1：内部使用单向链表来存储队列元素
2：元素的排序是按照FIFO的顺序，队列的第一个元素是入队列时间最久的那个元素（队列的头部）；
3：如果构造函数不指定大小，是无界的队列；如果指定大小，是有界队列，初始化时设置队列大小，之后不可再次设置；


BlockingQueue接口中的方法
序号方法描述
1 boolean add(E e) 将指定的元素插入到此队列中，如果可以立即执行此操作，而不会违反容量限制，在成功时返回true，并且如果当前没有空间可用，则抛出IllegalStateException。 
2 boolean contains(Object o) 如果此队列包含指定的元素，则返回true。 
3 int drainTo(Collection<? super E> c) 从该队列中删除所有可用的元素，并将它们添加到给定的集合中。 
4 int drainTo(Collection<? super E> c, int maxElements) 最多从该队列中删除给定数量的可用元素，并将它们添加到给定的集合中。 
5 boolean offer(E e) 将指定的元素插入到此队列中，如果可以立即执行此操作而不违反容量限制，则成功返回true，如果当前没有空间可用，则返回false。 
6 boolean offer(E e, long timeout, TimeUnit unit) 将指定的元素插入到此队列中，等待指定的等待时间(如有必要)才能使空间变得可用。 
7 E poll(long timeout, TimeUnit unit) 检索并删除此队列的头，等待指定的等待时间(如有必要)使元素变为可用。 
8 void put(E e) 将指定的元素插入到此队列中，等待空间/容量可用。 
9 int remainingCapacity() 返回此队列可理想地(在没有内存或资源约束的情况下)接受而不阻止的附加元素数，如果没有内在限制则返回Integer.MAX_VALUE。 
10 boolean remove(Object o) 从该队列中删除指定元素的单个实例(如果存在)。 
11 E take() 检索并删除此队列的头，如有必要，等待元素可用。 



1.2选择，服务器从内存中找servlet对象，如果没找到创建一个servlet对象，开线程，不是a就是b。。。



Java集合中那些类是线程安全的
线程安全类
在集合框架中，有些类是线程安全的，这些都是jdk1.1中的出现的。在jdk1.2之后，就出现许许多多非线程安全的类。 下面是这些线程安全的同步的类：
vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
statck：堆栈类，先进后出
hashtable：就比hashmap多了个线程安全
enumeration：枚举，相当于迭代器
除了这些之外，其他的都是非线程安全的类和接口。
线程安全的类其方法是同步的，每次只能一个访问。是重量级对象，效率较低。
其他：
1. hashtable跟hashmap的区别
hashtable是线程安全的,即hashtable的方法都提供了同步机制；hashmap不是线程安全的,即不提供同步机制 ；hashtable不允许插入空值,hashmap允许!
2. 多线程并发修改一 个 集合 怎么办
用老的Vector/Hashtable类
StringBuffer是线程安全，而StringBuilder是线程不安全的。对于安全与不安全没有深入的理解情况下，易造成这样的错觉，如果对于StringBuffer的操作均是线程安全的，然而，Java给你的保证的线程安全，是说它的方法是执行是排它的，而不是对这个对象本身的多次调用情况下，还是安全的。看看下边的例子，在StringBufferTest中有一个数据成员contents它是用来扩展的，它的每一次append是线程安全的，但众多次append的组合并不是线程安全的，这个输出结果不是太可控的，但如果对于log和getContest方法加关键字synchronized，那么结果就会变得非常条理，如果换成StringBuider甚至是append到一半，它也会让位于其它在此基础上操作的线程：



StringBuilder和StringBuffer的方法是一模一样，就是一个多线程和一个单线程的问题。线程调用同一StringBuffer 的append方法，这跟他是不是线程安全没有关系的，除非你的结果是append的一系列字符串变乱了，那才能说明他是线程不安全的。线程安全是指任何时刻都只有一个线程访问临界资源。线程安全 并不是说他的一系列操作是同步的 只是对于他执行某个方法的时候不允许别的线程去改变。针对一个类来说是不是线程安全就要看，多个线程在同时在运行，这些线程可能会同时执行某个方法。但是每次运行结果和单线程执行的结果一样，那么就可以说是线程安全的。因为log方法没有上锁，每个现在在append锁释放后，都可能得到cpu的执行片段。





这个代码是完全线程安全的，在方法内部定义的变量，在每个线程线程进入的时候都会创建这个局部变量！不涉及线程安全问题。通常涉及系统安全的变量一般都是成员变量! stringBuffer本身的内部实现是现场安全的！线程安全那是类本身提供的功能是安全的。即你提供插入一个字符串，那么这个字符串插入是安全的，但是要插入两个字符串，两个的顺序你来定，这之间如果有别的插入出错就不管类的事情了，是你自己代码的问题。







