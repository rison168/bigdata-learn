spark RDD功能与分类
2017-07-05 20:54 by BB99, 317 阅读, 0 评论, 收藏, 编辑算子的定义：RDD中定义的函数，可以对RDD中的数据进行转换和操作。下面根据算子类型的分类进行总结：
1. value型算子
    从输入到输出可分为一对一（包括cache）、多对一、多对多、输出分区为输入分区自激
    1)一对一，
        map,简单的一对一映射，集合不变；
        flatMap，一对一映射，并将最后映射结果整合；
        mappartitions,对分区内元素进行迭代操作，例如过滤等，然后分区不变
        glom,将分区内容转换成数据
    2）多对一，
        union，相同数据类型RDD进行合并，并不去重
        cartesian,对RDD内的所有元素进行笛卡尔积操作
    3）多对多，
        groupBy，将元素通过函数生成相应的Key，然后转化为Key-value格式
    4）输出分区为出入分区子集，
        filter，对RDD进行过滤操作，结果分区不调整
        distinct，对RDD进行去重操作，
        subtract，RDD间进行减操作，去除相同数据元素
        sample/takeSample 对RDD进行采样操作
    5）cache,
        cache,将RDD数据原样存入内存
        persist，对RDD数据进行缓存操作
2. Key-Value算子
    Key-Value算子大致可分为一对一，聚集，连接三类操作
    1）一对一，
        mapValues，针对数值对中的Value进行上面提到的map操作
    2）聚集操作
        combineByKey、reduceByKey、partitionBy、cogroup
    3）连接
        join、leftOutJoin、rightOutJoin
3. Actions算子
    该算子通过SparkContext执行提交作业操作，出发RDD DAG的执行
    1）foreach， 对RDD中每个元素进行操作，但是不返回RDD或者Array，只返回Unit
    2）存入HDFS,saveAsTextFile，saveAsObjectFile
    3）scala数据格式，collect，collectAsMap，reduceByKeyLocally， lookup， count， top， reduce， fold， aggregate





               list与Set、Map区别及适用场景

1、List,Set都是继承自Collection接口，Map则不是

2、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） 

3.Set和List对比： 
Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 


4.Map适合储存键值对的数据

5.线程安全集合类与非线程安全集合类 
LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;
HashMap是非线程安全的，HashTable是线程安全的;
StringBuilder是非线程安全的，StringBuffer是线程安全的。

下面是具体的使用介绍：
ArrayList与LinkedList的区别和适用场景

Arraylist：
优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。
缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。   
LinkedList：
优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景
缺点：因为LinkedList要移动指针,所以查询操作性能比较低。
适用场景分析：
 当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。


ArrayList与Vector的区别和适用场景

 ArrayList有三个构造方法：
Java代码  
public ArrayList(int initialCapacity)//构造一个具有指定初始容量的空列表。    
public ArrayList()//构造一个初始容量为10的空列表。    
public ArrayList(Collection<? extends E> c)//构造一个包含指定 collection 的元素的列表   
 Vector有四个构造方法：
Java代码  
public Vector()//使用指定的初始容量和等于零的容量增量构造一个空向量。    
public Vector(int initialCapacity)//构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。    
public Vector(Collection<? extends E> c)//构造一个包含指定 collection 中的元素的向量    
public Vector(int initialCapacity,int capacityIncrement)//使用指定的初始容量和容量增量构造一个空的向量    

ArrayList和Vector都是用数组实现的，主要有这么三个区别：

1.Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；
2.两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。
3.Vector可以设置增长因子，而ArrayList不可以。

4.Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。
适用场景分析：
1.Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。
2.如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。


HashSet与Treeset的适用场景

1.TreeSet 是二差树（红黑树的树据结构）实现的,Treeset中的数据是自动排好序的，不允许放入null值 

2.HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放





(1)什么是mvc?
是一种软件架构的思想，将软件按照模型、视图、控制器 来划分。
模型负责封装业务处理逻辑，视图负责输入和输出(表示逻辑)，控制器负责协调模型和视图。

模型：
封装：需要先写接口,然后实现接口中声明的方法。
业务处理逻辑：业务本身的处理流程，另外，还包括
为保证业务处理正常可靠执行的基础服务(事务、安全、
日志等等)。

视图:
输入：提供相应的操作界面，方便用户使用。
输出：将模型返回的结果以合适的方式来展现。

控制器:
协调: 视图向控制器发请求，由控制器来选择相应的
模型来处理；模型返回的结果给控制器，由控制器来
选择合适的视图，生成相应的界面给用户。

(2)mvc最大的优点：
可以实现模型的复用：
一方面，模型只返回处理结果，并不用关心这些结果如何展现。我们可以提供不同的视图来展现这些数据；
另外一方面，对于同一个模型，我们可以提供不同的操作界面来访问。

(3)开发一个web应用，如何使用mvc? (javaee)
1)模型使用java类来实现，视图使用jsp, 控制器使用servlet或者是filter来实现。
2)所有请求先发送给控制器(servlet),由控制器去选择模型(java类)来处理;模型的处理结果交给控制器,控制器选择视图(jsp)。



MVC开始是存在于Desktop（桌面）程序中的，M是指数据模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。
视图是用户看到并与之交互的界面，视图没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。
模型表示企业数据和业务规则，模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。
控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。


MVC设计模式考虑三种对象：模型对象、视图对象、和控制器对象。模型对象代表特别的知识和专业技能，它们负责保有应用程序的数据和定义操作数据的逻辑。视图对象知道如何显示应用程序的模型数据，而且可能允许用户对其进行编辑。控制器对象是应用程序的视图对象和模型对象之间的协调者。

m代表model模型，v代表view视图，c代表controller，控制器。m中包含你写的业务逻辑，就是取数据的模型，v代表你显示的视图，c来控制m和v之间的关系。mvc的运行原理基本一样没有什么不一样的地方，只是不同的mvc框架的实现技术不一样吧了。接下来我给你考一段网上的别人的看法；
模型－视图－控制器（MVC）是Xerox PARC在八十年代为编程语言Smalltalk－80发明的一种软件设计模式，至今已被广泛使用。最近几年被推荐为Sun公司J2EE平台的设计模式，并且受到越来越多的使用 ColdFusion 和 PHP 的开发者的欢迎。模型－视图－控制器模式是一个有用的工具箱，它有很多好处，但也有一些缺点。

MVC如何工作

MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。

视图
视图是用户看到并与之交互的界面。对老式的Web应用程序来说，视图就是由HTML元素组成的界面，在新式的Web应用程序中，HTML依旧在视图中扮演着重要的角色，但一些新的技术已层出不穷，它们包括Macromedia Flash和象XHTML，XML/XSL，WML等一些标识语言和Web services.
如何处理应用程序的界面变得越来越有挑战性。MVC一个大的好处是它能为你的应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。

模型
模型表示企业数据和业务规则。在MVC的三个部件中，模型拥有最多的处理任务。例如它可能用象EJBs和ColdFusion Components这样的构件对象来处理数据库。被模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。

控制器
控制器接受用户的输入并调用模型和视图去完成用户的需求。所以当单击Web页面中的超链接和发送HTML表单时，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后用确定用哪个视图来显示模型处理返回的数据。
现在我们总结MVC的处理过程，首先控制器接收用户的请求，并决定应该调用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器用相应的视图格式化模型返回的数据，并通过表示层呈现给用户。

为什么要使用 MVC
大部分Web应用程序都是用像ASP，PHP，或者CFML这样的过程化语言来创建的。它们将像数据库查询语句这样的数据层代码和像HTML这样的表示层代码混在一起。经验比较丰富的开发者会将数据从表示层分离开来，但这通常不是很容易做到的，它需要精心的计划和不断的尝试。MVC从根本上强制性的将它们分开。尽管构造MVC应用程序需要一些额外的工作，但是它给我们带来的好处是无庸质疑的。
首先，最重要的一点是多个视图能共享一个模型，正如我所提及的，现在需要用越来越多的方式来访问你的应用程序。对此，其中一个解决之道是使用MVC，无论你的用户想要Flash界面或是 WAP 界面；用一个模型就能处理它们。由于你已经将数据和业务规则从表示层分开，所以你可以最大化的重用你的代码了。
由于模型返回的数据没有进行格式化，所以同样的构件能被不同界面使用。例如，很多数据可能用HTML来表示，但是它们也有可能要用Macromedia Flash和WAP来表示。模型也有状态管理和数据持久性处理的功能，例如，基于会话的购物车和电子商务过程也能被Flash网站或者无线联网的应用程序所重用。
因为模型是自包含的，并且与控制器和视图相分离，所以很容易改变你的应用程序的数据层和业务规则。如果你想把你的数据库从MySQL移植到Oracle，或者改变你的基于RDBMS数据源到LDAP，只需改变你的模型即可。一旦你正确的实现了模型，不管你的数据来自数据库或是LDAP服务器，视图将会正确的显示它们。由于运用MVC的应用程序的三个部件是相互对立，改变其中一个不会影响其它两个，所以依据这种设计思想你能构造良好的松偶合的构件。
对我来说，控制器的也提供了一个好处，就是可以使用控制器来联接不同的模型和视图去完成用户的需求，这样控制器可以为构造应用程序提供强有力的手段。给定一些可重用的模型和视图，控制器可以根据用户的需求选择模型进行处理，然后选择视图将处理结果显示给用户。

MVC的缺点
MVC的缺点是由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。
你将不得不花费相当可观的时间去考虑如何将MVC运用到你的应用程序，同时由于模型和视图要严格的分离，这样也给调试应用程序到来了一定的困





public static int partition(int []array,int lo,int hi){
        //固定的切分方式
        int key=array[lo];
        while(lo<hi){
            while(array[hi]>=key&&hi>lo){//从后半部分向前扫描
                hi--;
            }
            array[lo]=array[hi];
            while(array[lo]<=key&&hi>lo){从前半部分向后扫描
                lo++;
            }
            array[hi]=array[lo];
        }
        array[hi]=key;
        return hi;
    }
    
    public static void sort(int[] array,int lo ,int hi){
        if(lo>=hi){
            return ;
        }
        int index=partition(array,lo,hi);
        sort(array,lo,index-1);
        sort(array,index+1,hi); 
    }




排序算法经过了很长时间的演变，产生了很多种不同的方法。对于初学者来说，对它们进行整理便于理解记忆显得很重要。每种算法都有它特定的使用场合，很难通用。因此，我们很有必要对所有常见的排序算法进行归纳。
排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。
内排序有可以分为以下几类：
　　(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。
　　(2)、选择排序：直接选择排序、堆排序。
　　(3)、交换排序：冒泡排序、快速排序。
　　(4)、归并排序
　　(5)、基数排序















